// +build exclude

package main

import (
	"bytes"
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
	"os/exec"
	"strings"
)

var (
	flagOut = flag.String("o", "doc.go", "out file")
)

func main() {
	flag.Parse()

	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, os.Getenv("GOPATH")+"/src/github.com/knq/hilink/client.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	var buf bytes.Buffer
	buf.WriteString(hdr)

	buf.WriteString("var methodParamMap = map[string][]string{\n")
	for _, d := range f.Decls {
		fd, ok := d.(*ast.FuncDecl)
		if ok && fd.Recv != nil {
			str := `"` + fd.Name.Name + `": []string{`
			for _, p := range fd.Type.Params.List {
				for _, n := range p.Names {
					str += `"` + n.Name + `",`
				}
			}
			str += "},\n"
			buf.WriteString(str)
		}
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var methodCommentMap = map[string]string{\n")
	for _, d := range f.Decls {
		fd, ok := d.(*ast.FuncDecl)
		if ok && fd.Recv != nil {
			str := `"` + fd.Name.Name + `": "` + strings.TrimSpace(strings.Replace(fd.Doc.Text(), "\n", " ", -1)) + "\",\n"
			buf.WriteString(str)
		}
	}
	buf.WriteString("}\n\n")

	out, err := os.Create(*flagOut)
	if err != nil {
		log.Fatal(err)
	}
	_, err = buf.WriteTo(out)
	if err != nil {
		log.Fatal(err)
	}
	err = out.Close()
	if err != nil {
		log.Fatal(err)
	}

	cmd := exec.Command("gofmt", "-w", *flagOut)
	err = cmd.Run()
	if err != nil {
		log.Fatal(err)
	}
}

const (
	hdr = `package main

// GENERATED BY gen.go

`
)
